#!/usr/bin/ruby -w
# wmii-3 configuration, written in Ruby.

$: << File.dirname(__FILE__)
require 'wmii'


# WM STARTUP
# give wmiiwm a chance to start and terminate other wmiirc
sleep 1 until Wmii.write('/event', "Start wmiirc\n")


# UI CONFIGURATION
ENV['WMII_FONT'] = '-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1'
ENV['WMII_SELCOLORS']='#ffffff #285577 #4c7899'
ENV['WMII_NORMCOLORS']='#222222 #eeeeee #666666'


# WM CONFIGURATION
Wmii.write '/def/border', 2
Wmii.write '/def/font', ENV['WMII_FONT']
Wmii.write '/def/selcolors', ENV['WMII_SELCOLORS']
Wmii.write '/def/normcolors', ENV['WMII_NORMCOLORS']
Wmii.write '/def/colmode', 'default'
Wmii.write '/def/colwidth', 0


# TAGGING RULES
Wmii.write '/def/rules', <<EOF
/QEMU.*/ -> ~
/jEdit.*/ -> code
/Buddy List.*/ -> mail
/.*thunderbird.*/ -> mail
/Gimp.*/ -> gimp
/Dia.*/ -> dia
/MPlayer.*/ -> ~
/xconsole.*/ -> ~
/alsamixer.*/ -> ~
/.*/ -> !
/.*/ -> 1
EOF


# MISC CONFIGURATION
system 'xsetroot -solid "#333333"'
system 'status &'

PROGRAM_MENU = Wmii.findPrograms(*ENV['PATH'].split(':')).join("\n")
ACTION_MENU = Wmii.findPrograms('/home/sun/dry/apps/wmii/etc/wmii-3', '~/.wmii-3').join("\n")


# KEY CONFIGURATION
MODKEY='Mod1'
UP='t'
DOWN='n'
LEFT='h'
RIGHT='s'

SELECT="#{MODKEY}-Control-"
SEND="#{SELECT}m,"
SWAP="#{SELECT}w,"
LAYOUT="#{SELECT}z,"
MENU="#{SELECT}"
PROGRAM="#{SELECT}"

SHORTCUTS = {
	"#{SELECT}#{LEFT}" => proc {Wmii.write '/view/ctl', 'select prev'},
	"#{SELECT}#{RIGHT}" => proc {Wmii.write '/view/ctl', 'select next'},
	"#{SELECT}#{DOWN}" => proc {Wmii.write '/view/sel/ctl', 'select next'},
	"#{SELECT}#{UP}" => proc {Wmii.write '/view/sel/ctl', 'select prev'},
	"#{SELECT}space" => proc {Wmii.write '/view/ctl', 'select toggle'},

	"#{SELECT}comma" => proc {Wmii.cycleView :left},
	"#{SELECT}period" => proc {Wmii.cycleView :right},


	"#{LAYOUT}w" => proc {Wmii.write '/view/sel/mode', 'default'},
	"#{LAYOUT}v" => proc {Wmii.write '/view/sel/mode', 'stack'},
	"#{LAYOUT}m" => proc {Wmii.write '/view/sel/mode', 'max'},
	"#{LAYOUT}z" => proc {Wmii.write '/view/0/sel/geom', '0 0 east south'},


	"#{MENU}i" => proc {system(Wmii.showMenu(ACTION_MENU) << '&')},
	"#{MENU}e" => proc {system(Wmii.showMenu(PROGRAM_MENU) << '&')},
	"#{MENU}v" => proc {Wmii.showView `wmiir read /tags | wmiimenu`},

	# focus any client by choosing from a menu
	"#{MENU}a" => proc do
		# prepare a list of menu choices
		choices = Wmii.readList('/client').inject([]) do |acc, id|
			tags = `wmiir read /client/#{id}/tags`
			name = `wmiir read /client/#{id}/name`.downcase

			acc << format("%d. [%s] %s", id, tags, name)
		end


		# show the menu and focus the chosen client
		target = Wmii.showMenu(choices.join("\n"))

		unless target.empty?
			Wmii.showClient target.scan(/\d+/).first
		end
	end,


	"#{PROGRAM}x" => proc {system 'terminal &'},
	"#{PROGRAM}k" => proc {system 'firefox &'},
	"#{PROGRAM}j" => proc {system 'beagle-search &'},
	"#{PROGRAM}q" => proc {system 'nautilus --no-desktop &'},


	"#{SEND}#{LEFT}" => proc {Wmii.write '/view/sel/sel/ctl', 'sendto prev'},
	"#{SEND}#{RIGHT}" => proc {Wmii.write '/view/sel/sel/ctl', 'sendto next'},
	"#{SEND}space" => proc {Wmii.write '/view/sel/sel/ctl', 'sendto toggle'},
	"#{SEND}Delete" => proc {Wmii.write '/view/sel/sel/ctl', 'kill'},
	"#{SEND}t" => proc {Wmii.write '/view/sel/sel/tags', `wmiir read /tags | wmiimenu`},

	# toggle maximizing the current client to full screen
	"#{SEND}m" => proc do
		SHORTCUTS["#{SEND}space"].call
		SHORTCUTS["#{LAYOUT}z"].call
	end,

	# rename the current view
	# NOTE: columns & layouts are not preserved
	"#{SEND}r" => proc do
		old = `wmiir read /view/name`
		new = Wmii.showMenu(`wmiir read /tags`)

		unless new.empty?
			Wmii.renameView old, new
			Wmii.showView new
		end
	end,


	"#{SWAP}#{LEFT}" => proc {Wmii.write '/view/sel/sel/ctl', 'swap prev'},
	"#{SWAP}#{RIGHT}" => proc {Wmii.write '/view/sel/sel/ctl', 'swap next'},
	"#{SWAP}#{DOWN}" => proc {Wmii.write '/view/sel/sel/ctl', 'swap down'},
	"#{SWAP}#{UP}" => proc {Wmii.write '/view/sel/sel/ctl', 'swap up'},
}

	# keyboard access to views (shown as labels on the WM bar)
	10.times do |i|
		# associate '1' with the leftmost label, instead of '0'
		k = (i - 1) % 10


		SHORTCUTS["#{SELECT}#{i}"] = proc {Wmii.showView(`wmiir read /tags`.split[k] || i)}
		SHORTCUTS["#{SEND}#{i}"] = proc {Wmii.write '/view/sel/sel/tags', (`wmiir read /tags`.split[k] || i)}
	end

Wmii.write '/def/grabmod', MODKEY
Wmii.write '/def/keys', SHORTCUTS.keys.join("\n")


# EVENT LOOP
IO.popen('wmiir read /event') do |io|
	while event = io.readline.chomp
		type, arg = event.split

		p event, type, arg if $DEBUG

		case type
			when 'Start'
				exit if arg == 'wmiirc'

			when 'BarClick'
				Wmii.showView arg

			when 'Key'
				SHORTCUTS[arg].call
		end
	end
end
