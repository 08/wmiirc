#!/usr/bin/ruby -w
# wmii-3 configuration, written in Ruby.
=begin
  Copyright 2006 Suraj N. Kurapati

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
=end

$: << File.dirname(__FILE__)
require 'wmii'


##
# WM STARTUP
#

WM = Wmii.new

# terminate existing wmiirc processes
  WM.event = "Start wmiirc\n"

PROGRAM_MENU = WM.find_programs(*ENV['PATH'].split(':')).join("\n")
ACTION_MENU = WM.find_programs('/home/sun/dry/apps/wmii/etc/wmii-3', '~/.wmii-3').join("\n")

# system 'xsetroot -solid "#333333"'


##
# UI CONFIGURATION
#

ENV['WMII_FONT'] = '-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1'
ENV['WMII_SELCOLORS']='#ffffff #285577 #4c7899'
ENV['WMII_NORMCOLORS']='#222222 #eeeeee #666666'


##
# WM CONFIGURATION
#

WM.config.instance_eval do
  border = 2

  font = ENV['WMII_FONT']
  selcolors = ENV['WMII_SELCOLORS']
  normcolors = ENV['WMII_NORMCOLORS']

  colmode = 'default'
  colwidth = 0

  rules = <<-EOS.gsub(/^\s+/, '')
    /QEMU.*/ -> ~
    /jEdit.*/ -> code
    /Buddy List.*/ -> chat
    /XChat.*/ -> chat
    /.*thunderbird.*/ -> mail
    /Gimp.*/ -> gimp
    /MPlayer.*/ -> ~
    /xconsole.*/ -> ~
    /alsamixer.*/ -> ~
    /.*/ -> !
    /.*/ -> 1
  EOS
end


##
# KEY CONFIGURATION
#

MODKEY='Mod1'
UP='t'
DOWN='n'
LEFT='h'
RIGHT='s'

FOCUS="#{MODKEY}-Control-"
SEND="#{FOCUS}m,"
SWAP="#{FOCUS}w,"
LAYOUT="#{FOCUS}z,"
MENU="#{FOCUS}"
PROGRAM="#{FOCUS}"
GROUP="#{FOCUS}g,"

SHORTCUTS = {
  # focus previous view
  "#{FOCUS}comma" => lambda do
    WM.cycle_view :left
  end,

  # focus next view
  "#{FOCUS}period" => lambda do
    WM.cycle_view :right
  end,

  # focus previous area
  "#{FOCUS}#{LEFT}" => lambda do
    WM.write '/view/ctl', 'select prev'
  end,

  # focus next area
  "#{FOCUS}#{RIGHT}" => lambda do
    WM.write '/view/ctl', 'select next'
  end,

  # focus floating area
  "#{FOCUS}space" => lambda do
    WM.write '/view/ctl', 'select toggle'
  end,

  # focus previous client
  "#{FOCUS}#{UP}" => lambda do
    WM.write '/view/sel/ctl', 'select prev'
  end,

  # focus next client
  "#{FOCUS}#{DOWN}" => lambda do
    WM.write '/view/sel/ctl', 'select next'
  end,


  "#{LAYOUT}w" => lambda do
    WM.write '/view/sel/mode', 'default'
  end,

  "#{LAYOUT}v" => lambda do
    WM.write '/view/sel/mode', 'stack'
  end,

  "#{LAYOUT}m" => lambda do
    WM.write '/view/sel/mode', 'max'
  end,

  "#{LAYOUT}z" => lambda do
    WM.write '/view/0/sel/geom', '0 0 east south'
  end,


  "#{LAYOUT}t" => lambda do
    WM.apply_tiling_layout
  end,

  "#{LAYOUT}g" => lambda do
    WM.apply_grid_layout
  end,


  "#{GROUP}g" => lambda do
    WM.current_client.invert_selection!
  end,

  "#{GROUP}a" => lambda do
    WM.current_view.select!
  end,

  "#{GROUP}i" => lambda do
    WM.current_view.invert_selection!
  end,

  "#{GROUP}n" => lambda do
    WM.select_none
  end,


  "#{MENU}i" => lambda do
    action = WM.show_menu(ACTION_MENU)
    system(action << '&') unless action.empty?
  end,

  "#{MENU}e" => lambda do
    program = WM.show_menu(PROGRAM_MENU)
    system(program << '&') unless program.empty?
  end,

  "#{MENU}Shift-v" => lambda do
    WM.focus_view(WM.show_menu(WM.read('/tags')))
  end,

  # focus any client by choosing from a menu
  "#{MENU}a" => lambda do
    choices = WM.clients.map do |c|
      format "%d. [%s] %s", c.index, c.tags, c.name.downcase
    end

    target = WM.show_menu(choices.join("\n"))

    unless target.empty?
      WM.focus_client target.scan(/\d+/).first
    end
  end,


  "#{PROGRAM}x" => lambda do system 'terminal &' end,
  "#{PROGRAM}k" => lambda do system 'epiphany &' end,
  "#{PROGRAM}j" => lambda do system 'nautilus --no-desktop &' end,


  "#{SEND}#{LEFT}" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'sendto prev'
    end
  end,

  "#{SEND}#{RIGHT}" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'sendto next'
    end
  end,

  "#{SEND}space" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'sendto toggle'
    end
  end,

  "#{SEND}Delete" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'kill'
    end
  end,

  # change the tag of the current client
  # +tag -tag idea from Jonas Pfenniger <http://zimbatm.oree.ch/articles/2006/06/15/wmii-3-and-ruby>
  "#{SEND}t" => lambda do
    choices = WM.tags.map {|t| [t, "+#{t}", "-#{t}"]}.flatten
    target = WM.show_menu(choices.join("\n"))

    WM.selected_clients.each do |c|
      c.with_tags do
        case target
          when /^\+/
            push $'

          when /^\-/
            delete $'

          else
            clear
            push target
        end
      end
    end
  end,

  # send to temporary view or switch back again
  "#{SEND}Shift-t" => lambda do
    curView = WM.current_view.name

    if curView =~ /~\d+$/
      WM.selected_clients.each do |c|
        c.with_tags do
          delete curView
        end
      end

      WM.focus_view $`
    else
      tmpView = "#{curView}~#{Time.now.to_i}"

      WM.selected_clients.each do |c|
        c.with_tags do
          push tmpView
        end
      end

      WM.focus_view tmpView
      WM.apply_grid_layout
    end
  end,

  "#{SEND}d" => lambda do
    # WM.with_selection do
      WM.detach_current_client
    # end
  end,

  "#{SEND}Shift-d" => lambda do
    # WM.with_selection do
      WM.attach_last_client
    # end
  end,

  # toggle maximizing the current client to full screen
  "#{SEND}m" => lambda do
    SHORTCUTS["#{SEND}space"].call
    SHORTCUTS["#{LAYOUT}z"].call
  end,


  "#{SWAP}#{LEFT}" => lambda do WM.write '/view/sel/sel/ctl', 'swap prev' end,
  "#{SWAP}#{RIGHT}" => lambda do WM.write '/view/sel/sel/ctl', 'swap next' end,
  "#{SWAP}#{DOWN}" => lambda do WM.write '/view/sel/sel/ctl', 'swap down' end,
  "#{SWAP}#{UP}" => lambda do WM.write '/view/sel/sel/ctl', 'swap up' end,
}

  # keyboard access to views (shown as labels on the WM bar)
  10.times do |i|
    k = (i - 1) % 10	# associate '1' with the leftmost label, instead of '0'

    SHORTCUTS["#{FOCUS}#{i}"] = lambda do
      WM.focus_view(WM.tags[k] || i)
    end

    SHORTCUTS["#{SEND}#{i}"] = lambda do
      WM.selected_clients.each do |c|
        c.tags = (WM.tags[k] || i)
      end
    end

    SHORTCUTS["#{LAYOUT}#{i}"] = lambda do
      WM.apply_grid_layout i
    end


    # shortcuts for adding and removing tags of a client
    SHORTCUTS["#{SEND}equal,#{i}"] =
    SHORTCUTS["#{SEND}Shift-equal,#{i}"] = lambda do
      WM.selected_clients.each do |c|
        c.with_tags do
          push(WM.tags[k] || i)
        end
      end
    end

    SHORTCUTS["#{SEND}minus,#{i}"] = lambda do
      WM.selected_clients.each do |c|
        c.with_tags do
          delete(WM.tags[k] || i)
        end
      end
    end

    SHORTCUTS["#{SEND}Shift-minus"] = lambda do
      WM.selected_clients.each do |c|
        c.with_tags do
          delete WM.current_view.name
        end
      end
    end
  end

  ('a'..'z').each do |char|
    SHORTCUTS["#{MENU}v,#{char}"] = lambda do
      if view = WM.tags.select {|t| t =~ /^#{char}/i}.first
        WM.focus_view view
      end
    end
  end

WM.config.grabmod = MODKEY
WM.config.keys = SHORTCUTS.keys.join("\n")


##
# MINI SCRIPTS
#

# display time and system status in the bar
  Thread.new do
    status = WM.create("/bar/status")
    status.colors = ENV['WMII_NORMCOLORS']

    loop do
      uptime = `uptime`.scan(/\d+\.\d+/).join(' ')

      5.times do
        status.data = "#{Time.now.to_s} | #{uptime}"
        sleep 2
      end
    end
  end

##
# EVENT LOOP
#

begin
  IO.popen('wmiir read /event') do |io|
    while event = io.readline.chomp
      type, arg = event.split($;, 2)

      p event, type, arg if $DEBUG

      case type
        when 'Start'
          exit if arg == 'wmiirc'

        when 'BarClick'
          view, button = arg.split
          WM.focus_view view

        when 'ClientClick'
          client, button = arg.split
          Wmii::Client.new("/client/#{client}").invert_selection!

        when 'Key'
          SHORTCUTS[arg].call
      end
    end
  end
rescue EOFError
  exit # wmiiwm has quit
end
