#!/usr/bin/ruby -w
# wmii-3 configuration, written in Ruby.
=begin
	Copyright 2006 Suraj N. Kurapati

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
=end

ENV['LC_ALL'] = 'te_IN.UTF-8'

$: << File.dirname(__FILE__)
require 'wmii'


WM = Wmii.instance

# WM STARTUP
# terminate other running wmiirc
sleep 1 until WM.write('/event', "Start wmiirc\n")


# UI CONFIGURATION
ENV['WMII_FONT'] = '-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1'
ENV['WMII_SELCOLORS']='#ffffff #285577 #4c7899'
ENV['WMII_NORMCOLORS']='#222222 #eeeeee #666666'


# WM CONFIGURATION
WM.write '/def/border', 2
WM.write '/def/font', ENV['WMII_FONT']
WM.write '/def/selcolors', ENV['WMII_SELCOLORS']
WM.write '/def/normcolors', ENV['WMII_NORMCOLORS']
WM.write '/def/colmode', 'default'
WM.write '/def/colwidth', 0


# TAGGING RULES
WM.write '/def/rules', <<EOF
/QEMU.*/ -> ~
/jEdit.*/ -> code
/Buddy List.*/ -> chat
/XChat.*/ -> chat
/.*thunderbird.*/ -> mail
/Gimp.*/ -> gimp
/MPlayer.*/ -> ~
/xconsole.*/ -> ~
/alsamixer.*/ -> ~
/.*/ -> !
/.*/ -> 1
EOF


# MISC CONFIGURATION
# system 'xsetroot -solid "#333333"'
system 'status &'

PROGRAM_MENU = WM.findPrograms(*ENV['PATH'].split(':')).join("\n")
ACTION_MENU = WM.findPrograms('/home/sun/dry/apps/wmii/etc/wmii-3', '~/.wmii-3').join("\n")


# KEY CONFIGURATION
MODKEY='Mod1'
UP='t'
DOWN='n'
LEFT='h'
RIGHT='s'

SELECT="#{MODKEY}-Control-"
SEND="#{SELECT}m,"
SWAP="#{SELECT}w,"
LAYOUT="#{SELECT}z,"
MENU="#{SELECT}"
PROGRAM="#{SELECT}"

SHORTCUTS = {
	"#{SELECT}#{LEFT}" => lambda do WM.write '/view/ctl', 'select prev' end,
	"#{SELECT}#{RIGHT}" => lambda do WM.write '/view/ctl', 'select next' end,
	"#{SELECT}#{DOWN}" => lambda do WM.write '/view/sel/ctl', 'select next' end,
	"#{SELECT}#{UP}" => lambda do WM.write '/view/sel/ctl', 'select prev' end,
	"#{SELECT}space" => lambda do WM.write '/view/ctl', 'select toggle' end,

	"#{SELECT}comma" => lambda do WM.cycleView :left end,
	"#{SELECT}period" => lambda do WM.cycleView :right end,


	"#{LAYOUT}w" => lambda do WM.write '/view/sel/mode', 'default' end,
	"#{LAYOUT}v" => lambda do WM.write '/view/sel/mode', 'stack' end,
	"#{LAYOUT}m" => lambda do WM.write '/view/sel/mode', 'max' end,
	"#{LAYOUT}z" => lambda do WM.write '/view/0/sel/geom', '0 0 east south' end,

	"#{LAYOUT}t" => lambda do WM.applyTilingLayout end,
	"#{LAYOUT}g" => lambda do WM.applyGridLayout end,


	"#{MENU}i" => lambda do
		action = WM.showMenu(ACTION_MENU)
		system(action << '&') unless action.empty?
	end,

	"#{MENU}e" => lambda do
		program = WM.showMenu(PROGRAM_MENU)
		system(program << '&') unless program.empty?
	end,

	"#{MENU}v" => lambda do WM.showView(WM.showMenu(WM.read('/tags'))) end,

	# focus any client by choosing from a menu
	"#{MENU}a" => lambda do
		# prepare a list of menu choices
		choices = WM.read('/client').split.inject([]) do |acc, id|
			tags = WM.read("/client/#{id}/tags")
			name = WM.read("/client/#{id}/name").downcase

			acc << format("%d. [%s] %s", id, tags, name)
		end


		# show the menu and focus the chosen client
		target = WM.showMenu(choices.join("\n"))

		unless target.empty?
			WM.showClient target.scan(/\d+/).first
		end
	end,


	"#{PROGRAM}x" => lambda do system 'terminal &' end,
	"#{PROGRAM}k" => lambda do system 'epiphany &' end,
	"#{PROGRAM}j" => lambda do system 'nautilus --no-desktop &' end,


	"#{SEND}#{LEFT}" => lambda do WM.write '/view/sel/sel/ctl', 'sendto prev' end,
	"#{SEND}#{RIGHT}" => lambda do WM.write '/view/sel/sel/ctl', 'sendto next' end,
	"#{SEND}space" => lambda do WM.write '/view/sel/sel/ctl', 'sendto toggle' end,
	"#{SEND}Delete" => lambda do WM.write '/view/sel/sel/ctl', 'kill' end,

	# change the tag of the current client
	# +tag -tag idea from Jonas Pfenniger <http://zimbatm.oree.ch/articles/2006/06/15/wmii-3-and-ruby>
	"#{SEND}t" => lambda do
		choices = WM.read('/tags').split.map {|t| [t, "+#{t}", "-#{t}"]}.flatten
		tags = WM.read('/view/sel/sel/tags').split('+')

		case target = WM.showMenu(choices.join("\n"))
			when /^\+/
				tags << $'

			when /^\-/
				tags.delete $'

			else
				tags = [target]
		end

		WM.write '/view/sel/sel/tags', tags.join('+')
	end,

	"#{SEND}d" => lambda do WM.detachClient end,
	"#{SEND}a" => lambda do WM.attachClient end,

	# toggle maximizing the current client to full screen
	"#{SEND}m" => lambda do
		SHORTCUTS["#{SEND}space"].call
		SHORTCUTS["#{LAYOUT}z"].call
	end,

	# rename the current view
	# NOTE: columns & layouts are not preserved
	"#{SEND}r" => lambda do
		old = WM.read('/view/name')
		new = WM.showMenu(WM.read('/tags'))

		unless new.empty?
			WM.renameView old, new
			WM.showView new
		end
	end,


	"#{SWAP}#{LEFT}" => lambda do WM.write '/view/sel/sel/ctl', 'swap prev' end,
	"#{SWAP}#{RIGHT}" => lambda do WM.write '/view/sel/sel/ctl', 'swap next' end,
	"#{SWAP}#{DOWN}" => lambda do WM.write '/view/sel/sel/ctl', 'swap down' end,
	"#{SWAP}#{UP}" => lambda do WM.write '/view/sel/sel/ctl', 'swap up' end,
}

	# keyboard access to views (shown as labels on the WM bar)
	10.times do |i|
		k = (i - 1) % 10	# associate '1' with the leftmost label, instead of '0'

		SHORTCUTS["#{SELECT}#{i}"] = lambda do WM.showView(WM.read('/tags').split[k] || i) end
		SHORTCUTS["#{SEND}#{i}"] = lambda do WM.write '/view/sel/sel/tags', (WM.read('/tags').split[k] || i) end
		SHORTCUTS["#{LAYOUT}#{i}"] = lambda do WM.applyGridLayout i end
	end

WM.write '/def/grabmod', MODKEY
WM.write '/def/keys', SHORTCUTS.keys.join("\n")


# EVENT LOOP
begin
	IO.popen('wmiir read /event') do |io|
		while event = io.readline.chomp
			type, arg = event.split

			p event, type, arg if $DEBUG

			case type
				when 'Start'
					exit if arg == 'wmiirc'

				when 'BarClick'
					WM.showView arg

				when 'Key'
					SHORTCUTS[arg].call

				when 'CreateClient'
					WM.applyTilingLayout if WM.read("/client/#{arg}/tags").split('+').include? WM.read('/view/name')
			end
		end
	end
rescue EOFError
	exit # wmiiwm has quit
end
