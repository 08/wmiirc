#!/usr/bin/ruby -w
# wmii-3 configuration, written in Ruby.
=begin
  Copyright 2006 Suraj N. Kurapati

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
=end

$: << File.dirname(__FILE__)
require 'Wmii'


## WM STARTUP

WM = Wmii.new
PROGRAM_MENU = WM.find_programs(*ENV['PATH'].split(':')).join("\n")
ACTION_MENU = WM.find_programs('~/dry/apps/wmii/etc/wmii-3', '~/.wmii-3').join("\n")

# terminate existing wmiirc processes
sleep 1 until WM.event = "Start wmiirc\n"


## UI CONFIGURATION

ENV['WMII_FONT'] = '-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1'
ENV['WMII_SELCOLORS']='#ffffff #285577 #4c7899'
ENV['WMII_NORMCOLORS']='#222222 #eeeeee #666666'

system %{xsetroot -solid '#333333'}


## WM CONFIGURATION

WM.config.border = 2

WM.config.font = ENV['WMII_FONT']
WM.config.selcolors = ENV['WMII_SELCOLORS']
WM.config.normcolors = ENV['WMII_NORMCOLORS']

WM.config.colmode = 'default'
WM.config.colwidth = 0

TAGGING_RULES = {
  '~' => [
    'QEMU.*',
    'MPlayer.*',
    'xconsole.*',
    'alsamixer.*',
  ],

  :code => [
    'jEdit.*',
  ],

  :chat => [
    'Buddy List.*', # gaim
    'XChat.*',
  ],

  :gimp => ['Gimp.*'],

  '!' => ['.*'],
  '1' => ['.*'],
}

WM.config.rules = TAGGING_RULES.inject('') do |memo, (tag, regexps)|
  regexps.each do |re|
    memo << "/#{re}/ -> #{tag}\n"
  end

  memo
end


## KEY CONFIGURATION

MODKEY='Mod1'
UP='t'
DOWN='n'
LEFT='h'
RIGHT='s'

DEFAULT="#{MODKEY}-Control-"
FOCUS=DEFAULT
SEND="#{FOCUS}m,"
SWAP="#{FOCUS}w,"
LAYOUT="#{FOCUS}z,"
MENU="#{FOCUS}"
PROGRAM="#{FOCUS}"
GROUP="#{FOCUS}g,"

SHORTCUTS = {
  # focus previous view
  "#{FOCUS}comma" => lambda do
    WM.cycle_view :left
  end,

  # focus next view
  "#{FOCUS}period" => lambda do
    WM.cycle_view :right
  end,

  # focus previous area
  "#{FOCUS}#{LEFT}" => lambda do
    WM.current_view.ctl = 'select prev'
  end,

  # focus next area
  "#{FOCUS}#{RIGHT}" => lambda do
    WM.current_view.ctl = 'select next'
  end,

  # focus floating area
  "#{FOCUS}space" => lambda do
    WM.current_view.ctl = 'select toggle'
  end,

  # focus previous client
  "#{FOCUS}#{UP}" => lambda do
    WM.current_area.ctl = 'select prev'
  end,

  # focus next client
  "#{FOCUS}#{DOWN}" => lambda do
    WM.current_area.ctl = 'select next'
  end,


  "#{LAYOUT}w" => lambda do
    WM.current_area.mode = 'default'
  end,

  "#{LAYOUT}v" => lambda do
    WM.current_area.mode = 'stack'
  end,

  "#{LAYOUT}m" => lambda do
    WM.current_area.mode = 'max'
  end,

  "#{LAYOUT}z" => lambda do
    WM.current_view[0].foci.geom = '0 0 east south'
  end,


  "#{LAYOUT}t" => lambda do
    WM.current_view.apply_tile_layout
  end,

  "#{LAYOUT}g" => lambda do
    WM.current_view.apply_grid_layout
  end,


  "#{GROUP}g" => lambda do
    WM.current_client.invert_selection!
  end,

  "#{GROUP}a" => lambda do
    WM.current_view.select!
  end,

  "#{GROUP}i" => lambda do
    WM.current_view.invert_selection!
  end,

  "#{GROUP}n" => lambda do
    WM.select_none
  end,


  "#{MENU}i" => lambda do
    action = WM.show_menu(ACTION_MENU)
    system(action << '&') unless action.empty?
  end,

  "#{MENU}e" => lambda do
    program = WM.show_menu(PROGRAM_MENU)
    system(program << '&') unless program.empty?
  end,

  "#{MENU}Shift-v" => lambda do
    WM.focus_view(WM.show_menu(WM.read('/tags')))
  end,

  # focus any client by choosing from a menu
  "#{MENU}a" => lambda do
    choices = WM.clients.map do |c|
      format "%d. [%s] %s", c.index, c.tags, c.name.downcase
    end

    target = WM.show_menu(choices.join("\n"))

    unless target.empty?
      WM.focus_client target.scan(/\d+/).first
    end
  end,


  "#{PROGRAM}x" => lambda do system 'terminal &' end,
  "#{PROGRAM}k" => lambda do system 'epiphany &' end,
  "#{PROGRAM}j" => lambda do system 'nautilus --no-desktop &' end,


  "#{SEND}#{LEFT}" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'sendto prev'
    end
  end,

  "#{SEND}#{RIGHT}" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'sendto next'
    end
  end,

  "#{SEND}space" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'sendto toggle'
    end
  end,

  "#{SEND}Delete" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'kill'
    end
  end,

  # change the tag of the current client
  # +tag -tag idea from Jonas Pfenniger <http://zimbatm.oree.ch/articles/2006/06/15/wmii-3-and-ruby>
  "#{SEND}t" => lambda do
    choices = WM.tags.map {|t| [t, "+#{t}", "-#{t}"]}.flatten
    target = WM.show_menu(choices.join("\n"))

    WM.selected_clients.each do |c|
      c.with_tags do
        case target
          when /^\+/
            push $'

          when /^\-/
            delete $'

          else
            clear
            push target
        end
      end
    end
  end,

  # remove current view from current selection's tags
  "#{SEND}Shift-minus" => lambda do
    WM.selected_clients.each do |c|
      c.with_tags do
        delete WM.current_view.name
      end
    end
  end,

  # send to temporary view or switch back again
  "#{DEFAULT}b" => lambda do
    curView = WM.current_view.name

    if curView =~ /~\d+$/
      WM.selected_clients.each do |c|
        c.with_tags do
          delete curView
          push $` if empty?
        end
      end

      WM.focus_view $`

    else
      tmpView = "#{curView}~#{Time.now.to_i}"

      WM.selected_clients.each do |c|
        c.with_tags do
          push tmpView
        end
      end

      WM.focus_view tmpView
      WM.current_view.apply_grid_layout
    end
  end,

  "#{SEND}d" => lambda do
    WM.with_selection do |c|
      c.focus!
      WM.detach_current_client
    end
  end,

  "#{SEND}Shift-d" => lambda do
    # WM.with_selection do
      WM.attach_last_client
    # end
  end,

  # toggle maximizing the current client to full screen
  "#{SEND}m" => lambda do
    SHORTCUTS["#{SEND}space"].call
    SHORTCUTS["#{LAYOUT}z"].call
  end,

  # swap the current client with the one to its left
  "#{SWAP}#{LEFT}" => lambda do
    WM.current_client.ctl = 'swap prev'
  end,

  # swap the current client with the one to its right
  "#{SWAP}#{RIGHT}" => lambda do
    WM.current_client.ctl = 'swap next'
  end,

  # swap the current client with the one below it
  "#{SWAP}#{DOWN}" => lambda do
    WM.current_client.ctl = 'swap down'
  end,

  # swap the current client with the one above it
  "#{SWAP}#{UP}" => lambda do
    WM.current_client.ctl = 'swap up'
  end,
}

10.times do |i|
  k = (i - 1) % 10	# associate '1' with the leftmost label, instead of '0'

  # focus _i_th view
  SHORTCUTS["#{FOCUS}#{i}"] = lambda do
    WM.focus_view(WM.tags[k] || i)
  end

  # send selection to _i_th view
  SHORTCUTS["#{SEND}#{i}"] = lambda do
    WM.selected_clients.each do |c|
      c.tags = (WM.tags[k] || i)
    end
  end

  # apply grid layout with _i_ clients per column
  SHORTCUTS["#{LAYOUT}#{i}"] = lambda do
    WM.current_view.apply_grid_layout i
  end

  # add _i_th view to current selection's tags
  SHORTCUTS["#{SEND}equal,#{i}"] =
  SHORTCUTS["#{SEND}Shift-equal,#{i}"] = lambda do
    WM.selected_clients.each do |c|
      c.with_tags do
        push(WM.tags[k] || i)
      end
    end
  end

  # remove _i_th view from current selection's tags
  SHORTCUTS["#{SEND}minus,#{i}"] = lambda do
    WM.selected_clients.each do |c|
      c.with_tags do
        delete(WM.tags[k] || i)
      end
    end
  end
end

# jump to view whose name begins with the pressed key
('a'..'z').each do |char|
  SHORTCUTS["#{MENU}v,#{char}"] = lambda do
    choices = WM.tags
    choices.delete WM.current_view.name

    if view = choices.select {|t| t =~ /^#{char}/i}.first
      WM.focus_view view
    end
  end
end

WM.config.grabmod = MODKEY
WM.config.keys = SHORTCUTS.keys.join("\n")


## MINI SCRIPTS

# display time and system status in the bar
  Thread.new do
    status = WM.create("/bar/status")
    status.colors = ENV['WMII_NORMCOLORS']

    loop do
      uptime = `uptime`.scan(/\d+\.\d+/).join(' ')

      5.times do
        status.data = "#{Time.now.to_s} | #{uptime}"
        sleep 1
      end
    end
  end


## EVENT LOOP

begin
  IO.popen('wmiir read /event') do |io|
    while event = io.readline.chomp
      type, arg = event.split($;, 2)

      case type
        when 'Start'
          exit if arg == 'wmiirc'

        when 'BarClick'
          view, button = arg.split

          case button.to_i
            when 1
              WM.focus_view view

            when 2
              WM.selected_clients.each do |c|
                c.with_tags do
                  push view
                end
              end

            when 3
              WM.selected_clients.each do |c|
                c.with_tags do
                  delete view
                end
              end
          end

        when 'ClientClick'
          client, button = arg.split

          if button.to_i == 3
            Wmii::Client.new("/client/#{client}").invert_selection!
          end

        when 'Key'
          SHORTCUTS[arg].call
      end
    end
  end
rescue EOFError
  exit # wmiiwm has quit
end
