#!/usr/bin/ruby -w
# wmii-3 configuration, written in Ruby.
=begin
  Copyright 2006 Suraj N. Kurapati

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
=end

$: << File.dirname(__FILE__)
require 'wm'
require 'rc'


## WM STARTUP

WM = Wmii.new
PROGRAM_MENU = find_programs( ENV['PATH'].squeeze(':').split(':') )
ACTION_MENU = find_programs('~/dry/apps/wmii/etc/wmii-3', '~/.wmii-3')

# terminate existing wmiirc processes
sleep 1 until WM.event = "Start wmiirc\n"


## UI CONFIGURATION

ENV['WMII_FONT'] = '-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1'
ENV['WMII_SELCOLORS']='#ffffff #285577 #4c7899'
ENV['WMII_NORMCOLORS']='#222222 #eeeeee #666666'

system %{xsetroot -solid '#333333'}


## WM CONFIGURATION

WM.def.border = 2

WM.def.font = ENV['WMII_FONT']
WM.def.selcolors = ENV['WMII_SELCOLORS']
WM.def.normcolors = ENV['WMII_NORMCOLORS']

WM.def.colmode = 'default'
WM.def.colwidth = 0

WM.def.rules = <<EOS
/jEdit.*/ -> code
/Buddy List.*/ -> chat
/XChat.*/ -> chat
/.*thunderbird.*/ -> mail
/Gimp.*/ -> gimp
/QEMU.*/ -> ~
/MPlayer.*/ -> ~
/xconsole.*/ -> ~
/alsamixer.*/ -> ~
/.*/ -> !
/.*/ -> 1
EOS


## KEY CONFIGURATION

MODKEY = 'Mod1'
UP = 't'
DOWN = 'n'
LEFT = 'h'
RIGHT = 's'
PRIMARY = 1
MIDDLE = 2
SECONDARY = 3

ACTION = "#{MODKEY}-Control-"
FOCUS = ACTION
SEND = "#{ACTION}m,"
SWAP = "#{ACTION}w,"
LAYOUT = "#{ACTION}z,"
GROUP = "#{ACTION}g,"
MENU = ACTION
PROGRAM = ACTION


SHORTCUTS = {
  # focus previous view
  "#{FOCUS}comma" => lambda do
    WM.cycle_view :left
  end,

  # focus next view
  "#{FOCUS}period" => lambda do
    WM.cycle_view :right
  end,

  # focus previous area
  "#{FOCUS}#{LEFT}" => lambda do
    WM.focused_view.ctl = 'select prev'
  end,

  # focus next area
  "#{FOCUS}#{RIGHT}" => lambda do
    WM.focused_view.ctl = 'select next'
  end,

  # focus floating area
  "#{FOCUS}space" => lambda do
    WM.focused_view.ctl = 'select toggle'
  end,

  # focus previous client
  "#{FOCUS}#{UP}" => lambda do
    WM.focused_area.ctl = 'select prev'
  end,

  # focus next client
  "#{FOCUS}#{DOWN}" => lambda do
    WM.focused_area.ctl = 'select next'
  end,


  "#{LAYOUT}w" => lambda do
    WM.focused_area.mode = 'default'
  end,

  "#{LAYOUT}v" => lambda do
    WM.focused_area.mode = 'stack'
  end,

  "#{LAYOUT}m" => lambda do
    WM.focused_area.mode = 'max'
  end,

  "#{LAYOUT}z" => lambda do
    WM.focused_view[0].sel.geom = '0 0 east south'
  end,


  "#{LAYOUT}t" => lambda do
    WM.focused_view.tile!
  end,

  "#{LAYOUT}g" => lambda do
    WM.focused_view.grid!
  end,


  "#{GROUP}g" => lambda do
    WM.focused_client.invert_selection!
  end,

  "#{GROUP}a" => lambda do
    WM.focused_view.select!
  end,

  "#{GROUP}i" => lambda do
    WM.focused_view.invert_selection!
  end,

  "#{GROUP}n" => lambda do
    WM.select_none
  end,


  "#{MENU}i" => lambda do
    action = show_menu(ACTION_MENU)
    system(action << '&') unless action.empty?
  end,

  "#{MENU}e" => lambda do
    program = show_menu(PROGRAM_MENU)
    system(program << '&') unless program.empty?
  end,

  "#{MENU}Shift-v" => lambda do
    WM.focus_view(show_menu(WM.tags))
  end,

  # focus any client by choosing from a menu
  "#{MENU}a" => lambda do
    choices = WM.clients.map do |c|
      format "%d. [%s] %s", c.index, c.tags, c.name.downcase
    end

    target = show_menu(choices)

    unless target.empty?
      WM.focus_client target.scan(/\d+/).first
    end
  end,


  "#{PROGRAM}x" => lambda do system 'terminal &' end,
  "#{PROGRAM}k" => lambda do system 'epiphany &' end,
  "#{PROGRAM}j" => lambda do system 'nautilus --no-desktop &' end,


  "#{SEND}#{LEFT}" => lambda do
    WM.with_selection do |c|
      c.ctl = 'sendto prev'
    end
  end,

  "#{SEND}#{RIGHT}" => lambda do
    WM.with_selection do |c|
      c.ctl = 'sendto next'
    end
  end,

  "#{SEND}space" => lambda do
    WM.with_selection do |c|
      c.ctl = 'sendto toggle'
    end
  end,

  "#{SEND}Delete" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'kill'
    end
  end,

  # change the tag of the currently focused client
  # +tag -tag idea from Jonas Pfenniger <http://zimbatm.oree.ch/articles/2006/06/15/wmii-3-and-ruby>
  "#{SEND}t" => lambda do
    choices = WM.tags.map {|t| [t, "+#{t}", "-#{t}"]}.flatten
    target = show_menu(choices)

    WM.selected_clients.each do |c|
      c.with_tags do
        case target
          when /^\+/
            push $'

          when /^\-/
            delete $'

          else
            clear
            push target
        end
      end
    end
  end,

  # remove currently focused view from current selection's tags
  "#{SEND}Shift-minus" => lambda do
    WM.selected_clients.each do |c|
      c.with_tags do
        delete WM.focused_view.name
      end
    end
  end,

  # send to temporary view or switch back again
  "#{ACTION}b" => lambda do
    curView = WM.focused_view.name

    if curView =~ /~\d+$/
      WM.selected_clients.each do |c|
        c.with_tags do
          delete curView
          push $` if empty?
        end
      end

      WM.focus_view $`

    else
      tmpView = "#{curView}~#{Time.now.to_i}"

      WM.selected_clients.each do |c|
        c.with_tags do
          push tmpView
        end
      end

      WM.focus_view tmpView
      WM.focused_view.grid!
    end
  end,

  # wmii-2 style detaching
  "#{ACTION}d" => lambda do
    WM.detach_selection
  end,

  # wmii-2 style detaching
  "#{ACTION}Shift-d" => lambda do
    WM.attach_last_client
  end,

  # toggle maximizing the currently focused client to full screen
  "#{SEND}m" => lambda do
    SHORTCUTS["#{SEND}space"].call
    SHORTCUTS["#{LAYOUT}z"].call
  end,

  # swap each selected client with the one to its left
  "#{SWAP}#{LEFT}" => lambda do
    WM.with_selection do |c|
      c.ctl = 'swap prev'
    end
  end,

  # swap each selected client with the one to its right
  "#{SWAP}#{RIGHT}" => lambda do
    WM.with_selection do |c|
      c.ctl = 'swap next'
    end
  end,

  # swap each selected client with the one below it
  "#{SWAP}#{DOWN}" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'swap down'
    end
  end,

  # swap each selected client with the one above it
  "#{SWAP}#{UP}" => lambda do
    WM.selected_clients.each do |c|
      c.ctl = 'swap up'
    end
  end,
}

10.times do |i|
  k = (i - 1) % 10	# associate '1' with the leftmost label, instead of '0'

  # focus _i_th view
  SHORTCUTS["#{FOCUS}#{i}"] = lambda do
    WM.focus_view(WM.tags[k] || i)
  end

  # send selection to _i_th view
  SHORTCUTS["#{SEND}#{i}"] = lambda do
    WM.selected_clients.each do |c|
      c.tags = (WM.tags[k] || i)
    end
  end

  # apply grid layout with _i_ clients per column
  SHORTCUTS["#{LAYOUT}#{i}"] = lambda do
    WM.focused_view.grid! i
  end

  # add _i_th view to current selection's tags
  SHORTCUTS["#{SEND}equal,#{i}"] =
  SHORTCUTS["#{SEND}Shift-equal,#{i}"] = lambda do
    WM.selected_clients.each do |c|
      c.with_tags do
        push(WM.tags[k] || i)
      end
    end
  end

  # remove _i_th view from current selection's tags
  SHORTCUTS["#{SEND}minus,#{i}"] = lambda do
    WM.selected_clients.each do |c|
      c.with_tags do
        delete(WM.tags[k] || i)
      end
    end
  end
end

# jump to view whose name begins with the pressed key
('a'..'z').each do |char|
  SHORTCUTS["#{MENU}v,#{char}"] = lambda do
    choices = WM.tags
    choices.delete WM.focused_view.name

    if view = choices.select {|t| t =~ /^#{char}/i}.first
      WM.focus_view view
    end
  end
end

WM.def.grabmod = MODKEY
WM.def.keys = SHORTCUTS.keys.join("\n")


## MINI SCRIPTS

# display time and system status in the bar
  Thread.new do
    status = IxpNode.new("/bar/status", true)
    status.colors = ENV['WMII_NORMCOLORS']

    loop do
      upTime = `uptime`.scan(/\d+\.\d+/).join(' ')
      diskUsage = `df -h ~`.split[-3..-1].join(' ')

      5.times do
        status.data = "#{Time.now.to_s} | #{upTime} | #{diskUsage}"
        sleep 1
      end
    end
  end


## EVENT LOOP

begin
  IO.popen('wmiir read /event') do |io|
    while event = io.readline.chomp
      type, arg = event.split($;, 2)

      case type
        when 'Start'
          exit if arg == 'wmiirc'

        when 'BarClick'
          viewId, mouseBtn = arg.split

          case mouseBtn.to_i
            when PRIMARY
              WM.focus_view viewId

            when MIDDLE
              WM.selected_clients.each do |c|
                c.with_tags do
                  push viewId
                end
              end

            when SECONDARY
              WM.selected_clients.each do |c|
                c.with_tags do
                  delete viewId
                end
              end
          end

        when 'ClientClick'
          clientId, mouseBtn = arg.split

          case mouseBtn.to_i
            when MIDDLE, SECONDARY
              Wmii::Client.new("/client/#{clientId}").invert_selection!
          end

        when 'Key'
          SHORTCUTS[arg].call
      end
    end
  end
rescue EOFError
  exit # wmiiwm has quit
end
