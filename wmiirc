#!/usr/bin/ruby -w
# Loader for ruby-based wmii configuration.
#--
# Copyright 2006-2007 Suraj N. Kurapati
# Copyright 2007      Nick Stenning
# See the file named LICENSE for details.

# load the wmii-irb library
  $: << File.join(File.dirname(__FILE__), 'wmii-irb')
  require 'wm'

  include Wmii

# create a logger to aid debugging
  require 'logger'

  LOG = Logger.new(__FILE__ + '.log', 5)

  # capture standard output in logger
  unless $DEBUG
    class << LOG
      alias write <<  # emulate IO.write
    end

    $stdout = $stderr = LOG
  end

LOG.info "birth"

begin
  # Miniature DSL to ease configuration.

    class Handler < Hash
      # When a block is given, registers a handler for the given key.
      # Otherwise, executes all registered handlers for the given key.
      def handle aKey, *aArgs, &aBlock
        if block_given?
          (self[aKey] ||= []) << aBlock

        elsif key? aKey
          self[aKey].each do |block|
            block.call(*aArgs)
          end
        end
      end
    end

    EVENTS  = Handler.new
    ACTIONS = Handler.new
    KEYS    = Handler.new

    def event *a, &b
      EVENTS.handle(*a, &b)
    end

    def action *a, &b
      ACTIONS.handle(*a, &b)
    end

    def key *a, &b
      a.map! { |x| x.respond_to?(:flatten) ? x.flatten.join('-') : x }
      KEYS.handle a.join(','), &b
    end

  # Utility functions

    # Shows a menu with the given items and returns the chosen item.
    # If nothing was chosen, then *nil* is returned.
    def show_menu aChoices, aPrompt = nil
      cmd = "dmenu -b -fn #{WMII_FONT.inspect} " <<
            %w[-nf -nb -sf -sb].zip(
              Color::NORMAL.split[0,2] + Color::FOCUSED.split[0,2]
            ).flatten!.map! {|s| s.inspect}.join(' ')

      cmd << " -p #{aPrompt.to_s.inspect}" if aPrompt

      IO.popen cmd, 'r+' do |menu|
        menu.puts aChoices
        menu.close_write

        choice = menu.read
        choice unless choice.empty?
      end
    end


    require 'pathname'

    # Returns the names of programs present in the given directories.
    def find_programs *aDirs
      aDirs.flatten.map do |d|
        Pathname.new(d).expand_path.children rescue []
      end.flatten.map do |f|
        f.basename.to_s if f.file? and f.executable?
      end.compact.uniq.sort
    end

  # terminate existing instances of this program
    fs.event << 'Start wmiirc'

    event :Start do |arg|
      exit if arg == 'wmiirc'
    end

  # load user's configuration file
    load File.join(File.dirname(__FILE__), 'wmiirc-config.rb')

    # Tag bar setup
      fs.lbar.clear

      tags.each do |tag|
        color = (tag == current_tag) ? Color::FOCUSED : Color::NORMAL

        bar = fs.lbar[tag]
        bar.create
        bar.write "#{color} #{tag}"
      end

    # Keygrab setup
      fs.keys = KEYS.keys.join("\n")

      event :Key do |*args|
        key(*args)
      end

    # Event loop
      fs.event.open do |bus|
        loop do
          bus.read.split("\n").each do |event|
            type, parms = event.split(' ', 2)

            args = parms.split(' ') rescue []
            event type.to_sym, *args
          end
        end
      end

rescue => e
  LOG.error e

  # allow the user to rescue themselves
    system 'xterm &'

    IO.popen('xmessage -file - -buttons recover:0,ignore:1', 'w') do |f|
      f.puts e.inspect, e.backtrace
    end

    if $?.exitstatus == 0
      system $0 + ' &'
    end

rescue Exception => e
  LOG.fatal e
end

LOG.info "death"
