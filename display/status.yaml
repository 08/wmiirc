import:
  - display/barlet

control:
  event:
    RightBarClick: |
      clicked_button, clicked_file = argv
      Status[clicked_file].mouse clicked_button

script:
  - after: |
      class StatusBarlet < Barlet
        def initialize path
          super path, :right
        end
      end

      class Status < Sandbox
        @@by_name = {}
        @@by_file = {}

        class << self
          ##
          # Returns the status bar applet that
          # is associated with the given name.
          #
          # [name]
          #   Either the the user-defined name of
          #   the status bar applet or the basename
          #   of the status bar applet's IXP file.
          #
          def [] name
            @@by_name[name] || @@by_file[name]
          end

          def each &block
            @@by_name.each_value(&block)
          end

          include Enumerable
        end

        def initialize name, definition, position
          @definition = definition

          if code = definition['script']
            instance_eval code,
              CONFIG.origin(code, "display:status:#{name}:script")
          end

          code = definition['label']
          instance_eval "def label; #{code}; end",
            CONFIG.origin(code, "display:status:#{name}:label")

          # buttons appear in ASCII order of their IXP file name
          # so prepend a number to get ordered status bar applets
          file = (name.start_with? "!" )? name : "#{position}-#{name}"
          @button = StatusBarlet.new(file)

          colors_hash = CONFIG['display']['color']
          @refresh = Thread.new do
            loop do
              button_label = begin
                Array(self.label)
              rescue Exception => e
                LOG.error e
                [colors_hash['error'], e]
              end

              # provide default color
              possible_color = button_label.first.to_s
              if colors_hash.key? possible_color
                button_label[0] = colors_hash[possible_color]
              elsif possible_color !~ /(?:#[[:xdigit:]]{6} ?){3}/
                button_label.unshift colors_hash['normal']
              end

              @button.colors = button_label.shift
              @button.label = button_label.join(' ')

              sleep(*Array(definition['refresh']))
            end
          end

          # register this instance
          @@by_name[name] = self
          @@by_file[file] = self
        end

        ##
        # Updates the label of this applet.
        #
        def refresh
          @refresh.wakeup if @refresh.alive?
        end

        ##
        # Invokes the mouse action associated with the given mouse button.
        #
        # ==== Parameters
        #
        # [button]
        #   Either the identification number of the
        #   mouse button (as defined by X server) or
        #   a named action corresponding to such as
        #   identification number that was clicked.
        #
        def mouse button
          if action_by_mouse = @definition['mouse_action']
            mouse = Mouse[button]

            if action = action_by_mouse[mouse]
              Wmiirc.action action
            end
          end
        end

        ##
        # Provides method-call access to parameters in
        # the YAML definition of this status bar applet.
        #
        def method_missing method_name
          param_name = method_name.to_s
          if @definition.key? param_name
            @definition[param_name]
          else
            super
          end
        end
      end

      # find all status bar applet definitions, which can
      # be nested deeply in the display:status namespace
      applets = []

      find_applets = lambda do |name, definition|
        if definition.respond_to? :key? and definition.key? 'label'
          applets << [name, definition]
        elsif definition.respond_to? :each_value
          definition.each do |child_name, child_definition|
            child_path = [name, child_name].compact.join(':')
            find_applets.call child_path, child_definition
          end
        end
      end

      find_applets.call nil, CONFIG['display']['status']

      # populate the status bar with applet instances
      fs.rbar.clear

      applets.each_with_index do |(name, definition), position|
        # TODO: recursive merge with override logging like Wmiirc::Config.merge()
        instances = Array(definition['instances']).map {|h| definition.merge h }

        # user did not specify any instances, so treat the status
        # bar applet definition as an implicit singleton instance
        instances << definition if instances.empty?

        instances.each_with_index do |instance, offset|
          Status.new name, instance, "#{position}-#{offset}"
        end
      end
