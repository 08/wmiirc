#
# Ruby code in this file has access to a CONFIG constant which contains the
# data in this configuration file.  It also has access to a SESSION constant
# which is a hash that is persisted across multiple instances of this wmiirc.
#

##
# A list of configuration files (partials) to import before
# evaluating this configuration file.  Imported partials may
# import other partials, recursively.  The contents of each
# successive partial are merged with the previous one.  As a
# result, the contents of the current file *always overwrite*
# the contents of the partials imported by the current file.
#
# How this overwriting occurs depends on the type of object being overwritten:
#
# * If the object being overwritten is a hash, then:
#
#   (1) for keys that are present in the old hash but absent in the new hash,
#       key-value pairs from the old hash are retained.
#
#   (2) for keys that are present in the new hash but absent in the old hash,
#       key-value pairs from the new hash are added.
#
#   (3) for keys in common between the old and new hashes, key-value pairs
#       from the old hash are replaced by key-value pairs from the new hash.
#
# * If the object being overwritten is an array, then items from the new array
#   are appended to end of the old array.
#
# * If the object being overwritten is a scalar value such as a string,
#   integer, or boolean, then the old value is replaced by the new value.
#
import:

##
# A list of Ruby libraries to load before evaluating this configuration file.
# If a library is a RubyGem, you can constrain its version number like this:
#
#   require:
#     - some_gem
#     - another_gem: '>= 1.0.9'
#     - yet_another_gem: ['>= 1.0.9', '< 2']
#     - some_ruby_library
#
require:

##
# Appearance settings.
#
display:

  ##
  # Where to display the horizontal status bar?
  #
  # Possible choices are "top" and "bottom".
  #
  bar:

  ##
  # Font to use in all text drawn by wmii.
  #
  font:

  ##
  # Thickness of client border (measured in pixels).
  #
  border:

  ##
  # Color schemes for everything drawn by wmii.
  #
  #   <scheme>: "<text> <background> <border>"
  #
  # You can find more color schemes here:
  #
  #   http://wmii.suckless.org/themes
  #
  # Unlike the other parameters in this section, the
  # "desktop" parameter only accepts a single color:
  #
  #   desktop: "<color>"
  #
  color:
    desktop:
    focus:
    normal:

  ##
  # Settings for columns drawn by wmii.
  #
  #   mode: <the wmii "colmode" setting>
  #   rule: <the wmii "colrules" setting>
  #
  column:
    mode:
    rule:

  ##
  # Settings for clients handled by wmii.
  #
  #   rule: <the wmii "rules" setting>
  #
  client:
    rule:

  ##
  # Global refresh rate for status bar applets (measured in seconds).
  #
  refresh:

  ##
  # Status bar applets. Array of hashes, each serving as arguments
  # for creating multiple instances of a certain status bar applet.
  #
  #   status:
  #     - <name of the status bar applet to instantiate>:
  #
  #         params:
  #           <parameter name>:  <parameter value>
  #
  #           These parameters are later available as instance variables in
  #           the Ruby code that is executed inside this status bar applet.
  #
  #         refresh:  <Number of seconds to wait before updating the
  #                    label.  To disable automatic refreshing, give
  #                    this parameter a `nil` value by omitting this
  #                    parameter completely or by omitting its value.
  #
  #                    DO NOT specify a *zero* value for this parameter;
  #                    doing so will cause massive delays in wmii's event
  #                    stream processing and will make wmii unresponsive!>
  #
  #
  #         script:   <Ruby code to evaluate in the Wmiirc::Status
  #                    object that corresponds to this definition.>
  #
  #         label:    <Ruby code whose result is displayed as the
  #                    content.  This code is placed inside a
  #                    label() method in the Wmiirc::Status object
  #                    that corresponds to this definition.>
  #
  #         control:
  #           action:
  #             <action name>: <Ruby code to evaluate in the Wmiirc::Status
  #                             object that corresponds to this definition.>
  #
  #           mouse_action:
  #             <mouse event>: <name of action>
  #
  #           keyboard_action:
  #             <key sequence>: <name of action>
  #
  # The horizontal order in which these applets appear on the status
  # bar reflects the vertical order in which they are defined below.
  #
  # Code evaluated inside a Wmiirc::Status object has access to a `refresh`
  # method which triggers redrawing of the label of that status bar applet.
  #
  status:

##
# Interaction settings.
#
control:

  ##
  # Internal scripts.
  #
  #   <action name>: <Ruby code to execute>
  #
  action:

  ##
  # Event handlers.
  #
  #   <event name>: <Ruby code to execute>
  #
  # The Ruby code has access to an "argv" variable which
  # is a list of arguments that were passed to the event.
  #
  # Keep in mind that these event handlers **block** the
  # wmiirc event loop --- meaning that no new events are
  # received and processed until the current one has been
  # fully handled.  So try to keep them short and quick.
  #
  # If your event handler needs to perform a
  # long-running operation, then be sure to
  # wrap that operation inside a Ruby thread.
  #
  event:

  ##
  # Mapping from X mouse codes to event names.
  #
  mouse:

    ##
    # The wmii "grabmod" setting.
    #
    grab:

  ##
  # Keyboard settings.
  #
  keyboard:

  ##
  # Keyboard shortcuts.
  #
  #   <key sequence>: <name of action>
  #
  # A key sequence may contain ${...} expressions which
  # are replaced with the value corresponding to '...' in
  # the "control:keyboard" section of this configuration.
  #
  # For example, if the "control:keyboard" section was:
  #
  #   control:
  #     keyboard:
  #       foo: Mod4
  #       bar: y
  #
  # and the following key sequence was used:
  #
  #   ${foo}-${bar},${bar}
  #
  # then after ${...} expression replacement,
  # that key sequence would appear like this:
  #
  #   Mod4-y,y
  #
  keyboard_action:

##
# Arbitrary logic to execute while processing this file.
#
#   script:
#     before:
#       - <Ruby code to execute before processing this file>
#       # ...
#     after:
#       - <Ruby code to execute after processing this file>
#       # ...
#
script:
  before:
  after:
